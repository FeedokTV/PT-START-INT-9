# Анализ драйвера

Спустя долгие две недели анализа (а точнее попыток запустить драйвер) всё таки я готов отправить заветный вердикт и некоторые мысли

(названия функций выбраны из IDA)

Перед нами драйвер, который работает с кэшем. Он инициализирует секции памяти, заполняет их, даёт информацию о них и делает PONG при запросе PING. Основная работа заключается в управлении структурами кэша и управление записями в нём.
Работа с драйвером происходит через IOCTL запросы, обрабатываемые HandleIoctl

# Методология поиска уязвимости

Здесь начинается самое интересное

1) Первая идея, которая меня посетила имея Before и After патчевые версии драйвера - сравнить драйвера побайтово по hex. Впринципе идея неплохая но вряд ли она покажет, что-то стоющее. Однако откладывать её я не хотел и подобный анализ привёл меня к функции _security_check_cookie, которая как мне показалось используется для освобождения памяти. И на самом деле в Before и After версии там есть изменения. Как я понял данная функция проверяет каким-то образом целостность стека или вроде того. Возможно эта вещь используется для защиты от переполнения буфера
Обе функции в двух версиях вызывают ExFreePoolWithTag но имеют различия в переходах. Также она имеет связь с release_entry. Возможно пропатченная версия более аккуратно обнуляет память.
2) Второй затеей было проверить всё таки код досканально с IDA. Проверить типы вводимых данных, сколько байт можно ввести и так далее. Я не силён в реверс инжиниринге но всё же какие-то вещи провернуть смог (как в пункте 1). Таким образом я пошёл сразу к коду обращения к драйверу (vrdrvclt) и начал пробовать. Следующие мысли у меня появились в голове:

"Раз я нахожу зацепки на работу с памятью, значит будем анализировать работу с ней, что логично. Драйвер работает с памятью (выделяет и так далее), а значит здесь будет хрупкое место. Всё что связано с памятью будет нашей поверхностью атаки, таким образом у нам есть
- Переполнение буффера (возможно)
- Работа с памятью после освобождения (возможно)"

Ну что гадать и я приступил.

Я пытался изменять размеры массивов и передаваемых данных в IOCTL_VR_SET в надежде, что он заполнит мне данные на больше чем надо. Собственно у меня и получилось. Если поставить arbSize меньше чем arbData в конце концов мы получим corrupted stack ошибку, что мне кажется то что нам нужно. Но это самое просто что можно было сделать\
Я решил пойти иначе и изменить вектор своей атаки. Я переключился на PING сообщение. Моей идеей было заполнить секцию PING сообщения вместо 8 байт которые отводятся для wchar_t, а использовать 16 и заполнить это в сообщение пинга
Затем отправил Ioctl запрос и всё прошло как по маслу (ну мне так кажется)

Конечно это не тот легендарный Buffer Overlflow, хотя кто его знает.
По идее можно было бы найти адрес возврата функции где обрабатываются запросы или где закрывается хэндл с девайсом и подстроить всё так, чтобы драйвер передал управление приложению в кернел моде (так по идее уязвимость в этом случае и должна работать), но пока это всё чего я мог добиться


**Дисклеймер и собственно причина почему так всё "сыро" и "недоделано"** 
Аналитику я люблю, особенно применять на практике, но к сожалению время и мой опыт играл против меня. Я никогда не сдаюсь даже если чего-то не знаю. Поэтому мысль и времени и нехватки опыта я откинул и вплоть до 1 июля я пытался отлаживать драйвер и находить в нём нужную информацию. Это было безумно интересно, но неумело :)). Поэтому сейчас (16:29) когда я пишу это к сожалению признаю своё первое поражение.
К сожалению мне нехватило понимания и опыта в отладки драйвера, поэтому далее будет только "полёт фантазии" и анализ


# PS
Однако хочу сказать спасибо за интересное задание, которое меня правда зацепило и над которым я сидел с начала и до конца. Давно так не получал удовольствия, как от анализа кода драйвера. Я понял где у меня дыры в знаниях и что нужно подтянуть. Однако с удосольствием получил бы опыт в вашем отделе. 
